drop table if exists user_boards;
drop table if exists cards;
drop table if exists lists;
drop table if exists boards;
drop table if exists users;

create table boards (
  id bigint generated by default as identity primary key,
  creator uuid references auth.users not null default auth.uid(),
  title text default 'Sem titúlo',
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create table lists (
  id bigint generated by default as identity primary key,
  board_id bigint references boards ON DELETE CASCADE not null,
  title text default '',
  position int not null default 0,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create table cards (
  id bigint generated by default as identity primary key,
  list_id bigint references lists ON DELETE CASCADE not null,
  board_id bigint references boards ON DELETE CASCADE not null,
  position int not null default 0,
  title text default '',
  description text check (char_length(description) > 0),
  assigned_to uuid references auth.users,
  done boolean default false,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create table user_boards (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users ON DELETE CASCADE not null default auth.uid(),
  board_id bigint references boards ON DELETE CASCADE
);

create table users (
  id uuid not null primary key,
  email text
);

alter table cards replica identity full;
alter table lists replica identity full;

create or replace function get_boards_for_authenticated_user()
returns setof bigint
language sql
security definer
set search_path = public
stable
as $$
    select board_id
    from user_boards
    where user_id = auth.uid()
$$;

alter table boards enable row level security;

create policy "Os usuários podem criar novos painéis" on boards for 
  insert to authenticated with CHECK (true);

create policy "Os usuários podem visualizar os próprios painéis" on boards for
    select using (
      id in (
        select get_boards_for_authenticated_user()
      )
    );

create policy "Os usuários podem atualizar os próprios painéis" on boards for
    update using (
      id in (
        select get_boards_for_authenticated_user()
      )
    );

create policy "Os usuários podem excluir os painéis criados" on boards for
    delete using (auth.uid() = creator);

alter table user_boards enable row level security;

create policy "Os usuários podem adicionar painéis" on user_boards for
    insert to authenticated with check (true);

create policy "Os usuários podem visualizar painéis" on user_boards for
    select using (auth.uid() = user_id);

create policy "Os usuários podem excluir seus painéis" on user_boards for
    delete using (auth.uid() = user_id);

alter table lists enable row level security;

create policy "Os usuários podem editar listas se fizerem parte do painel" on lists for
    all using (
      board_id in (
        select get_boards_for_authenticated_user()
      )
    );

alter table cards enable row level security;

create policy "Os usuários podem editar cartões se fizerem parte do painel" on cards for
    all using (
      board_id in (
        select get_boards_for_authenticated_user()
      )
    );
    
create function public.handle_board_added() 
returns trigger 
language plpgsql 
security definer 
as $$
begin
  insert into public.user_boards (board_id, user_id)
  values (new.id, auth.uid());
  return new;
end;
$$;

create trigger on_board_created
  after insert on boards
  for each row execute procedure public.handle_board_added();


create or replace function public.handle_new_user() 
returns trigger as $$
begin
  insert into public.users (id, email)
  values (new.id, new.email);
  return new;
end;
$$ language plpgsql security definer;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();